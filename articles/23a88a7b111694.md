---
title: "Remixのコンセプトの一部をNext.jsに導入する"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## Remixは何が優れているのか？

昨年11月下旬にRemixがv1のリリースを終え、そのタイミングでパブリックなOSSとなりました。
https://remix.run/blog/remix-v1

それ以降私は、RemixとNext.jsの両方を業務とプライベートの中で行き来しなら開発しているのですが、その中で個人的にこの点がRemixがイケていると思うところをまずは書き出してみます。
なおこの記事ではNext.jsに関してはSSRのみを取り扱います。

:::message
ぜひRemixについて更に詳しく知りたい方は、これらの記事を参考にしてください。
:::

https://zenn.dev/kaa_a_zu/articles/fbd06ca2cc3b86

https://zenn.dev/steelydylan/articles/remix-nextjs-comparison

### ミューテーションのエンドポイント

Next.jsはリクエストのハンドラが一つです。一方、RemixはGETを受ける`loader`とPOSTやDELETEなどGET以外のメソッドを受ける`action`の2つに別れます。
通常、Next.jsのgetServerSidePropsでFormDataをPOSTして受ける場合、Bodyのパースを自身で書く必要があります。そのため、[API Routes](https://nextjs.org/docs/api-routes/introduction) でミューテーション用のエンドポイントを増やすことが一般的です。
一方のRemixのactionで取り扱うrequestはハンドルする前に拡張されているため、直接FormDataを参照することが可能です。

https://remix.run/docs/en/v1/api/conventions#action

つまり、Remixは同一のエンドポイントでリクエストとミューテーションを行うことをポリシーとしており、Rails等の元来のWebフレームワークのようなRESTfulなエンドポイント構成になります。これによりロジックの凝縮が容易になります。
Next.jsでも同じように構成可能ですが、一定の拡張が必要になります。

### Cookieのハンドリングしやすさ

Next.jsでCookie取り扱う場合、nookiesなどの外部ライブラリを利用するのが一般的です。また公式のドキュメントを見てもCookieに関してNodeのRequest/Responseクラスの域を超えるようなプラクティスに関する記述貼りません。
https://github.com/maticzav/nookies

一方でRemixはフレームワークファーストでCookieのヘルパーが用意されています。
signed cookieにも対応しているため改ざんに対しての耐性もあります。
https://remix.run/docs/en/v1/api/remix#cookies

単純なヘルパーが用意されているだけであれば、大した違いはありませんし、現時点ではそうです。
しかしRemixの開発チームは、クライアントから可能な限りJSを排除し、状態管理さえもクライアントサイドからサーバサイドに移譲することを模索しているようです。
そのためにCookieをネイティブでサポートする必要があると意思決定したものと思われます。

:::details コラム (Remixはサーバサイド回帰をめざしてるのか？)
フロントエンドのフレームワークが成熟する前まで、状態管理はサーバサイドで行われるのが一般的でした。
それがクライアントサイドの状態管理のライブラリやノウハウが確立したことで、徐々に責務がクライアントサイドへうつっていきました。
一方で現在は、パフォーマンスのためにクライアントサイドからJSを減らしていこうという動きが活発になっています。
ということは、これはサーバサイドへまた回帰していくのでしょうか？

私は少し曖昧な答えになってしまいますが、これは半分正解で半分違うと思います。

現在のトレンドでは移譲する先はロケーションが固定されたバックエンドサーバではなく、物理的に距離の近いエッジファンクションです。

エッジネイティブであるためサーバサイドはクライアントから物理的に近いところにあり、またClowdflare Workersを選択すれば、Isolated V8 Sandbox環境であるため、ブラウザエンジンに近い実行環境です。
つまり、自身のデバイス上のブラウザと、物理的に近いところにもう一つ仮想のブラウザを持っていると考えて
:::



### 楽観的UI

loader/action
    - GETとそれ以外とでレシーバーが異なる
    - ReadとMutateとで処理は分離するが、エンドポイントは統一できる
    - useFetcherと組み合わせると、楽観的レンダリングが可能
- Cookieの取り扱いやすさ
    - signed cookieに対応しているので、漏洩だけでなく改ざんにも一定の耐性がある
- エッジで動くことをコンセプトにしている

- 状態管理をクライアントからサーバサイドへ移譲するための手助け
    - クライアント側のインタラクションに応じて、workerが起動し、新しい状態がworkerから降ってくる
        - バンドルサイズを大幅に削減し、クライアント依存なアンコントローラルブなものを排除できる
        - エッジであるとはいえ、ローカルで処理する数百倍の時間を要するので、楽観的レンダリングを差し込んでUXを下げないようにしている


- Outletコンポーネント(Nested Routing)
    - ナビゲーション時に反応する Dynamic Import
    - loaderはネストされたルートのすべてを通ってくる
        - ナビゲーション時は論理差分のルートのみのloader
    - ErrorBoundaryはこの単位
        - 例外発生時にページ全体がハングアップするのを防ぐ

コラム
そもそも、フロントエンドライブラリが勢力を拡大するまでは、サーバサイドでの状態管理が主流だった。じゃあ今の流れは回帰しているのか？
それはNo。worker ≠ (従来の)サーバ どちらかといえば、リモートにあるもう一つの閉じられたブラウザ




Next.jsでRemixぽく書く

- getServerSidePropsを分割
- Cookieを取り扱いやすくする
- 楽観的UI
