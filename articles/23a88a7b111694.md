---
title: "Remixのコンセプトの一部をNext.jsに導入する"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["remix", "nextjs"]
published: false
---

## Remixは何が優れているのか？

昨年11月下旬にRemixがv1のリリースを迎え、そのタイミングでパブリックなOSSとなりました。
https://remix.run/blog/remix-v1

それ以降私は、RemixとNext.jsの両方を業務とプライベートの中で行き来しなら開発しているのですが、その中で個人的にこの点がRemixがイケていると思うところをまずは書き出してみます。

ぜひRemixについて更に詳しく知りたい方は、こちらの記事も参考にしてください。

https://zenn.dev/kaa_a_zu/articles/fbd06ca2cc3b86

https://zenn.dev/steelydylan/articles/remix-nextjs-comparison

なおこの記事ではNext.jsに関してはSSRのみを取り扱います。

また、Remixの特徴としてよく挙げられる、Nested Routes や Error Boundary あえてこの記事では触れません。
上にあげた記事で詳しく説明されているのでぜひそちらを参照してください。

### ミューテーションのエンドポイント

Next.jsはリクエストのハンドラが一つです。一方、RemixはGETを受ける`loader`と、POSTやDELETEなどGET以外のメソッドを受ける`action`の2つに別れます。 

Next.jsのgetServerSidePropsでFormDataをPOSTして受ける場合、Bodyのパースを自身で書く必要があります。そのため、[API Routes](https://nextjs.org/docs/api-routes/introduction) でミューテーション用のエンドポイントを増やすことが一般的です。

一方のRemixのactionで取り扱うrequestはハンドルする前に拡張されているため、直接FormDataを参照することが可能です。

https://remix.run/docs/en/v1/api/conventions#action

つまり、Remixは同一のエンドポイントでリクエストとミューテーションを行うことをポリシーとしており、Rails等の元来のWebフレームワークのようなRESTfulなエンドポイント構成になります。これによりロジックの凝縮が容易になります。
Next.jsでも同じように構成可能ですが、一定の拡張が必要になります。

### Cookieのハンドリングしやすさ

Next.jsでCookie取り扱う場合、nookiesなどの外部ライブラリを利用するのが一般的です。
https://github.com/maticzav/nookies
getServerSidePropsで取り扱うrequestとresponseは、NodeのRequest/Responseとニアリーイコールですので、ライブラリを利用せずともCookieをハンドリングすることはできますが、フレームワークとしてCookieをゴリゴリに活用する思想ではないです。

一方でRemixはCookieのヘルパーがフレームワーク側に用意されています。
signed cookieにも対応しているため改ざんに対しての耐性もあるすぐれものです。
https://remix.run/docs/en/v1/api/remix#cookies

単純なヘルパーが用意されているだけであれば、大した違いはありません。
しかしRemixの開発チームは、クライアントから可能な限りJavascriptを排除し、状態管理をもクライアントサイドからサーバサイドに移譲することを模索しているようです。
そのためにCookieやキャッシュヘッダーをネイティブでサポートする必要があると意思決定したものと思われます。

:::details コラム (Remixはサーバサイド回帰をめざしてるのか？)
フロントエンドのフレームワークが成熟する前まで、状態管理はサーバサイドで行われるのが一般的でした。
それがクライアントサイドの状態管理のライブラリやノウハウが確立したことで、徐々に責務がクライアントサイドへ移る動きがありました。
一方で現在は、逆にパフォーマンスのためにクライアントサイドからJSを減らしていこうという動きが活発になっています。
ということは、これはサーバサイドへまた回帰していくのでしょうか？

少し曖昧な答えになってしまいますが、これは半分正解で半分違うと私は思います。

現在のトレンドでは移譲する先はロケーションが固定されたバックエンドサーバではなく、物理的に距離の近いエッジロケーション上のワーカーです。
Clowdflare Workersを選択すれば、Isolated V8 Sandbox環境であり、クライアントサイドコードがそのまま実行可能です。
ということは、自身のデバイス上のブラウザと、物理的に近いところにもう一つ仮想のブラウザを持っていることになり、状態管理はそこで行わるようになります。
ただの言葉遊びであって本質は変わっていないとも取れますが、Cloudflareが昨年末に買収した[Zaraz](https://zaraz.com/)などは、まさに仮想のブラウザをエッジロケーションに持つというコンセプトにかなり近く、ここ数年の中でそういった動きが加速していくと思われますし、Remixの開発メンバはCloudflareのチームとかなり密に連携しているため、思想が一致していると見るのが自然です。
:::

### 楽観的UI

先に述べた、Cookieを利用した状態管理のサーバサイド移譲に関して、「エッジロケーションで動かすため高速で応答が得られる」とはいえ、ローカルで実行結果を得るのとではレイテンシが全く違います。
その解決策として、Reimixは楽観的IU(レンダリング)による応答補完をネイティブにサポートしています。
https://remix.run/docs/en/v1/guides/optimistic-ui

エンドポイントとの通信の状況をハンドリングしサブミット中のデータからレスポンスを予測(期待)して、先にUI側に反映させることで、ローディングスピナ等の結果を待つための挙動を排除します。

楽観的UIをご存じない方は下記記事がわかりやすいのでどうぞ。
https://kaminashi-developer.hatenablog.jp/entry/optimistic-update-in-spa

---

以上が私が思うRemixのイケている機能であり、そして思想です。

そしてここからが本題です。

Remixのイケているところをあげましたが、では、Next.js と比較したときにすべてが優れているかというと、それは違います。
Next.js は SSR と SSG(ISR) の両方に対応していますし、開発チームはGoogleのAuroraチームと連携しているため、SEOのベストプラクティスを取り入れやすいです。
Vercelという地の利を得れば、実験的な機能を含めて、さまざまなエコシステムに乗っかることができます。

私は両方を業務とプライベートの開発に取り入れていますが、大部分はそれぞれのレールに乗りつつ、優れたものであれば、部分的に思想を交換するということが重要だと思います。

ということで、上にあげたRemixのイケているところをNext.jsに取り入れていきます。

- 同一のエンドポイントでリクエストとミューテーションを行う
- Cookieで状態管理する
- 楽観的UI

:::message
以降は、動作確認は取れており一定の稼働実績がありますが、実験的なものであるという認識をお願いします。
ご自身のリポジトリに適応する際は自己責任でお願いします。
:::

## Next.jsでRemixぽく書く

さて