---
title: "Remixのコンセプトの一部をNext.jsに導入する"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## Remixは何が優れているのか？

昨年11月下旬にRemixがv1のリリースを終え、そのタイミングでパブリックなOSSとなりました。
https://remix.run/blog/remix-v1

それ以降私は、RemixとNext.jsの両方を業務とプライベートの中で行き来しなら開発しているのですが、その中で個人的にこの点がRemixがイケていると思うところをまずは書き出してみます。
なおこの記事ではNext.jsに関してはSSRのみを取り扱います。

:::message
ぜひRemixについて更に詳しく知りたい方は、これらの記事を参考にしてください。
:::

https://zenn.dev/kaa_a_zu/articles/fbd06ca2cc3b86

https://zenn.dev/steelydylan/articles/remix-nextjs-comparison

### ミューテーションのエンドポイント

Next.jsはリクエストのハンドラが一つです。一方、RemixはGETを受ける`loader`とPOSTやDELETEなどGET以外のメソッドを受ける`action`の2つに別れます。
通常、Next.jsのgetServerSidePropsでFormDataをPOSTして受ける場合、Bodyのパースを自身で書く必要があります。そのため、[API Routes](https://nextjs.org/docs/api-routes/introduction) でミューテーション用のエンドポイントを増やすことが一般的です。
一方のRemixのactionで取り扱うrequestはハンドルする前に拡張されているため、直接FormDataを参照することが可能です。

https://remix.run/docs/en/v1/api/conventions#action

つまり、Remixは同一のエンドポイントでリクエストとミューテーションを行うことをポリシーとしており、Rails等の元来のWebフレームワークのようなRESTfulなエンドポイント構成になります。これによりロジックの凝縮が容易になります。
Next.jsでも同じように構成可能ですが、一定の拡張が必要になります。

### Cookieのハンドリングしやすさ

Next.jsでCookie取り扱う場合、nookiesなどの外部ライブラリを利用するのが一般的です。また公式のドキュメントを見てもCookieに関してNodeのRequest/Responseクラスの域を超えるようなプラクティスに関する記述貼りません。
https://github.com/maticzav/nookies

一方でRemixはフレームワークファーストでCookieのヘルパーが用意されています。

https://remix.run/docs/en/v1/api/remix#cookies



### 楽観的UI

loader/action
    - GETとそれ以外とでレシーバーが異なる
    - ReadとMutateとで処理は分離するが、エンドポイントは統一できる
    - useFetcherと組み合わせると、楽観的レンダリングが可能
- Cookieの取り扱いやすさ
    - signed cookieに対応しているので、漏洩だけでなく改ざんにも一定の耐性がある
- エッジで動くことをコンセプトにしている

- 状態管理をクライアントからサーバサイドへ移譲するための手助け
    - クライアント側のインタラクションに応じて、workerが起動し、新しい状態がworkerから降ってくる
        - バンドルサイズを大幅に削減し、クライアント依存なアンコントローラルブなものを排除できる
        - エッジであるとはいえ、ローカルで処理する数百倍の時間を要するので、楽観的レンダリングを差し込んでUXを下げないようにしている


- Outletコンポーネント(Nested Routing)
    - ナビゲーション時に反応する Dynamic Import
    - loaderはネストされたルートのすべてを通ってくる
        - ナビゲーション時は論理差分のルートのみのloader
    - ErrorBoundaryはこの単位
        - 例外発生時にページ全体がハングアップするのを防ぐ

コラム
そもそも、フロントエンドライブラリが勢力を拡大するまでは、サーバサイドでの状態管理が主流だった。じゃあ今の流れは回帰しているのか？
それはNo。worker ≠ (従来の)サーバ どちらかといえば、リモートにあるもう一つの閉じられたブラウザ




Next.jsでRemixぽく書く

- getServerSidePropsを分割
- Cookieを取り扱いやすくする
- 楽観的UI
