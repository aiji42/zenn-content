---
title: "PrismaDataProxyが遅いを解決する"
emoji: "🔮"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["prism","cloudrun","vercel","graphql"]
published: false
---

## 概要

PrismaDataProxyが遅いので、セルフホストするためのサーバライブラリを自作して解決しました、というお話です。

### PrismaDataProxy とは

Prisma.ioが提供する、データベース接続管理とプーリングのためのプロキシサーバです。
Cloudflare WorkersやVecel Edge Functionなどは、TCP接続に制限があるため、データベースとのネイティブ接続ができません。  
PrismaDataProxyデータベースとの接続の間に入り、WorkerからはHTTP接続でデータベースとの仮想接続を実現します。

![](/images/pdp-overview.png)

以降、長いのでPrismaDataProxyのことを**PDP**と記載します。

### PrismaDataProxy の弱点

PDPは https://cloud.prisma.io/ から、Webコンソール上でインスタンスを作成することで構築が可能です。  
しかし、2022/06/19現在、選択できるリージョンは、バージニア北部とフランクフルトの2拠点のみです。

![](/images/pdp-regions.png)

そして、サーバレスでのサービス提供となっておりコールドスタンバイによるレイテンシの影響も受けます。

PDPの利用ケースはCloudflare Workersなどのエッジサイドからのデータソース利用が大半ですが、そこでレイテンシが大きくなるとエッジケースのメリットは薄れてしまいます。  

手元の計測では、バージニア北部のインスタンスを選択し、同じリージョンにPlanetscaleを構築して接続した際に、コールドスタンバイ時では**2.6s前後**、コールドスタンバイなしでも**600ms前後**のレイテンシを観測しています。

これではサービスに投入することは非常に難しいですが、Prismaの強力な型生成機能の恩恵を受けたかったため、なんとかPDPを日本リージョンにセルフホストし、更にコールドスタンバイの影響の小さいアーキテクチャで構築できないかと考えました。

## Prisma Clientのコードを読む

まず、PDPのサーバソースが公開されていないかと思い探してみましたが、残念ながら公開はされていませんでした。  
そこで、Prisma Client側のコードを読み、PDPとどのような通信を行っているかを見ることで、ブラックボックスなPDPの内部を解き明かせないかと考えました。

PrismaのClientコードは、ライブラリモード(デフォルト)とバイナリモード、そしてDataProxyモードの3つにエンジンのコードが分かれています。
3つめのDataProxyモードのエンジンが、PDPと通信を行うコードです。

https://github.com/prisma/prisma/blob/main/packages/engine-core/src/data-proxy/DataProxyEngine.ts#L132-L145

`requestInternal`の実装をみると、GraphQLぽいリクエストをPDPのエンドポイントに投げていることがわかります。  

実際に、ソースに`console.log`を仕込んでbodyを除いてみると、`db.link.findMany({ select: { id: true, url: true }, where: { id: 1 } })`というクエリを実行したときに、このようなクエリが投げられていることが確認できました。
```graphql
query query {
  findManyLink(where: { id: 1 }) {
    id
    url
  }
}
```


例外はありますが、おおよそこのような法則になっていました。
```
[query|mutation] query {
  [オペレーション名][モデル名]([select以外の引数(where,take,skip,etc...)]) {
    selectで示したフィールド
    リレーションはオペレーションが入れ子になる
  }
}
```

create,update,delete系のオペレーションは`mudation`で。

この法則に従ったGraphQLサーバを構築すれば、PDPをセルフホストしたものに代替できそうです。

## PDP用のGraphQLサーバを仮組みする

実際に前述のリクエストに対応するスキーマとリゾルバを定義し、Apolloサーバを構築したときに正しく、Prisma Clientがレスポンスを正しく解釈できるか実験してみます。

```graphql
scalar DateTime
scalar Any

type Link {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  url: String!
  shortUrl: String!
  userId: String
  User: User
}

type User {
  id: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  name:      String!
  email:     String!
  links:     [Link!]!
}

type Query {
  findManyLink(where: Any): [Link!]!
}
```

```ts
const resolver = {
  Link: {
    User: ({ id }, args) => {
      return db.link.findUnique({ where: { id } }).User(args)
    }
  },
  Query: {
    findManyLink: (_, args) => {
      return db.link.findMany(args)
    }
  }
}
```