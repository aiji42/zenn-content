---
title: "CSRなサイトをSSG/ISRなサイトに変換する"
emoji: "🍋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs","react","rendertron"]
published: false
---

## この記事は何？

この記事は、「Next.jsのISRを独自に実装する」という記事の続編になります。

https://zenn.dev/chimame/articles/7570c71d1e6c38

上の記事では主にCloudflare WorkersのKVやDurable Objectsを駆使し、キャッシュのコントロールをうまく行うことで、ISRのベースである`
stale-while-revalidate`の挙動を再現するという内容になっており、まだ目を通してない方は合わせてご覧になることをおすすめします。

この記事では、上の記事中で紹介しきれなかった、アーキテクチャの後半部分である、CSRなページ・SPAなコンテンツをSGなページに変換するということについて紹介していきます。  

Next.jsの`getStaticProps`や`getServerSideProps`を使用すれば、サーバサイドでレンダリングされた静的なページを簡単に得ることができます。  
ここでは、そのどちらも使用していないCSRなページを現状のコード体系を変えることなく、ISRに変換するための手法について紹介します。

この記事では、最終的なオリジンはNext.jsのケースを紹介していますが、`create react app`で作成したような**完全にSPAなサイトでも同じ結果が得られるはずです**。

また、すでに`getStaticProps`や`getServerSideProps`を使用しているのであれば、上の記事の構成のみでISRの対応はすでに完了しています。

## アーキテクチャ

![](https://storage.googleapis.com/zenn-user-upload/5d5b6ce7aa99-20220625.png)

先に結論から述べると、キャッシュのハンドリングを行うWorkerとオリジンとの間に`Rendetron`を挟むことで、ユーザの代理でレンダリングをおこない、そのレンダリング結果のHTMLをWorkerにキャッシュさせて、擬似的なSG構成を構築しているといったアーキテクチャになります。

と、言葉で説明するのは簡単ですが、このアーキテクチャを構築するにあたって、解消しなければならない課題がいくつかあります。

- GraphQLクライアント等のデータフェッチが二重に起きないようにしないといけない
  - CSRの一番の課題はデータフェッチによるローディングのサスペンド
  - Rendetron上で先にデータフェッチがすんでいるので、クライアントではうまく省略したい
- Rendetron上で得た完全に静的なHTMLを返却して終わりではない
  - 最終的なユーザの手元ではインタラクティブに動くページになっていなければならない
  - しかし単純にHydrateするとHydrate Mismatchが起きる

### Rendertronに関して

先にあげた課題の解決方法の前に、Rendertronについて解説しておきます。  

https://developers.google.com/search/blog/2019/01/dynamic-rendering-with-rendertron?hl=ja

RendertronはGoogleのweb.devやlighthouseを開発しているコミュニティが作成した、ダイナミックレンダリングのためのミドルウェアです。

![ダイナミックレンダリング](https://developers.google.com/static/search/docs/advanced/images/how-dynamic-rendering-works.png?hl=ja)

Headless Chromiumを使用して仮想ブラウザ上でCSR・SPAなサイトをレンダリングし、静的なHTMLのみを返却することができます。

最近ではGoogleのクローラーもJSのレンダリング結果を解釈が可能になり、またSSRやSSGなどの登場によって、あまりクローラーと実ユーザとを区別する必要はなくなりました。  
しかし、少し前まではこのようなダイナミックレンダリングを利用する方法で、クローラーフレンドリーなサイトを構築する手法が、Googleからも提案されていました。

### Rendertronの改造

Rendertronを導入するに当たり、すこしソースの修正が必要になります。  
Rendertronの本来の目的は完全に静的なHTMLを得ることであり、そのため、最終的にscriptタグを排除する実装になっています。  

今回の構成では、事前レンダリングは行いますが、クライアントでインタラクティブなページを得るために、レンダリングに使用したJSは引き続き必要になります。

Rendertronのリポジトリをクローンするか、あるいは`patch-package`等でコードを変更します。

https://github.com/GoogleChrome/rendertron/blob/main/src/renderer.ts#L48-L94

上記コードの`stripPage`と`injectBaseHref`が不要ですので、それを消して準備は完了、公式のREADMEに従ってホスティングします。

#### 補足: prerenderに関して

Rendertronと同じようなものに、prerenderというものがあります。

https://github.com/prerender/prerender

こちらのライブラリもRendertronと同様にHeadless Chromiumを使用して事前レンダリングを行うミドルウェアです。
Rendertronとの違いはスクリプトタグを排除する処理はなく、また、プラグインを書いて任意の処理を挿入できます
そのため、実は今回のアーキテクチャにはPrerenderの方が最適です。

しかし、サーバレスでのホスティングが想定されておらず、Chromiumの立ち上がりよりも前にサーバのポートListenが始まってしまい、高頻度で5xxが発生してしまいます。  
これに関してはパッチを当てれば対応できますが、Chromiumのプロセスの管理がサーバレスと相性が良くないために、その後もレンダリングが失敗するケースが多発してしまい、あえなくRendertronを選択しました。

サーバレスな構成をとらないのであれば、Rendertronのほうがスムーズに構築ができると思いますので、自身の環境にあったものを選択してください。

### 二重データフェッチの抑制

Rendertronでの事前レンダリングでは、通常のブラウザと同じようにデータフェッチも発生します。  
そのデータフェッチの結果をうまくハンドリングすることで、ユーザのクライアントでのデータフェッチをスキップさせます。

これを実現するために、SSG・SSRなサイトとApollo ClientやRelay Modernを組み合わせる際にとる方法を参考にします。  
通常これらはgetServerSideProps内でデータをフェッチし、そのデータをクライアント側でキャッシュとしてリストア可能な形式でpage propsにして返却。
クライアント側ではデータフェッチ前にpage propsからキャッシュをリストアし、キャッシュでは足りない分だけフェッチするという感じで実装します。
うまくリストアできれば、初回の全データフェッチはスキップされ、即座にレンダリングが完了します。

これはApollo Clientの例です。
```ts
const cache = new InMemoryCache()
if (typeof window !== 'undefined') {
  // キャッシュをリストアする
  if (window.__APOLLO_STATE__)
    cache.restore(window.__APOLLO_STATE__)
    
  // キャッシュをhtmlに書き込むための関数
  window.extractApolloCache = () => {
    return JSON.stringify(cache.extract()).replace(/</g, '\\u003c')
  }
}
```

Rendertronの上で `window.extractApolloCache()` を実行し、HTML上にこのようなscriptタグを書き込みます。
```html
<script>
window.__APOLLO_STATE__ = [window.extractApolloCache()の実行結果]
</script>
```

ユーザクライアント側では、上のscriptタグが実行されることで`window.__APOLLO_STATE__`にキャッシュが格納され、`cache.restore(window.__APOLLO_STATE__)`の実行を通じて、Apollo Clientのデータストアにキャッシュとしてリストアされます。

さらに、キャッシュポリシーをこのようにしておくことで、最初のフェッチ(ランディング時)はキャッシュを優先し、ナビゲートなど2回目以降は最新のデータをフェッチしにいくようにコントロールできます。
```ts
return new ApolloClient({
  ...,
  defaultOptions: {
    watchQuery: {
      fetchPolicy: 'cache-first',
      nextFetchPolicy: 'cache-and-network',
    },
  },
})
```

こうすることで、Rendertronでのデータフェッチの結果を利用して、ユーザクライアントでのデータフェッチをスキップ、最終的にローディングスピナによるサスペンドを解消できます。

## Hydrate Mismatchの抑制

## パフォーマンスの変化

## まとめ
