---
title: "CSRなサイトをSSG/ISRなサイトに変換する"
emoji: "🍋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs","react","rendertron"]
published: false
---

## この記事は何？

この記事は、「Next.jsのISRを独自に実装する」という記事の続編になります。

https://zenn.dev/chimame/articles/7570c71d1e6c38

上の記事では主にCloudflare WorkersのKVやDurable Objectsを駆使し、キャッシュのコントロールをうまく行うことで、ISRのベースである`
stale-while-revalidate`の挙動を再現するという内容になっており、まだ目を通してない方は合わせてご覧になることをおすすめします。

この記事では、上の記事中で紹介しきれなかった、アーキテクチャの後半部分である、CSRなページ・SPAなコンテンツをSGなページに変換するということについて紹介していきます。  

Next.jsの`getStaticProps`や`getServerSideProps`を使用すれば、サーバサイドでレンダリングされた静的なページを簡単に得ることができます。  
ここでは、そのどちらも使用していないCSRなページを現状のコード体系を変えることなく、ISRに変換するための手法について紹介します。

この記事では、最終的なオリジンはNext.jsのケースを紹介していますが、`create react app`で作成したような**完全にSPAなサイトでも同じ結果が得られるはずです**。

また、すでに`getStaticProps`や`getServerSideProps`を使用しているのであれば、上の記事の構成のみでISRの対応はすでに完了しています。

## アーキテクチャ

![](https://storage.googleapis.com/zenn-user-upload/5d5b6ce7aa99-20220625.png)

先に結論から述べると、キャッシュのハンドリングを行うWorkerとオリジンとの間に`Rendetron`を挟むことで、ユーザの代理でレンダリングをおこない、そのレンダリング結果のHTMLをWorkerにキャッシュさせて、擬似的なSG構成を構築しているといったアーキテクチャになります。

と、言葉で説明するのは簡単ですが、このアーキテクチャを構築するにあたって、解消しなければならない課題がいくつかあります。

- GraphQLクライアント等のデータフェッチが二重に起きないようにしないといけない
  - CSRの一番の課題はデータフェッチによるローディングのサスペンド
  - Rendetron上で先にデータフェッチがすんでいるので、クライアントではうまく省略したい
- Rendetron上で得た完全に静的なHTMLを返却して終わりではない
  - 最終的なユーザの手元ではインタラクティブに動くページになっていなければならない
  - しかし単純にHydrateするとHydrate Mismatchが起きる


### Rendertronに関して

先にあげた課題の解決方法の前に、Rendertronについて解説しておきます。  

https://developers.google.com/search/blog/2019/01/dynamic-rendering-with-rendertron?hl=ja

RendertronはGoogleのweb.devやlighthouseを開発しているコミュニティが作成した、ダイナミックレンダリングのためのミドルウェアです。

![ダイナミックレンダリング](https://developers.google.com/static/search/docs/advanced/images/how-dynamic-rendering-works.png?hl=ja)

Headless Chromiumを使用して仮想ブラウザ上でCSR・SPAなサイトをレンダリングし、静的なHTMLのみを返却することができます。

最近ではGoogleのクローラーもJSのレンダリング結果を解釈が可能になり、またSSRやSSGなどの登場によって、あまりクローラーと実ユーザとを区別する必要はなくなりました。  
しかし、少し前まではこのようなダイナミックレンダリングを利用する方法で、クローラーフレンドリーなサイトを構築する手法が、Googleからも提案されていました。

### Rendertronの改造

Rendertronを導入するに当たり、すこしソースの修正が必要になります。  
Rendertoronの本来の目的は完全に静的なHTMLを得ることであり、そのため、最終的にscriptタグを排除する実装になっています。  

今回の構成では、事前レンダリングは行いますが、クライアントでインタラクティブなページを得るために、レンダリングに使用したJSは引き続き必要になります。

Rendertoronのリポジトリをクローンするか、あるいは`patch-package`等でコードを変更します。

https://github.com/GoogleChrome/rendertron/blob/main/src/renderer.ts#L48-L94

上記コードの`stripPage`と`injectBaseHref`が不要ですので、それを消して準備は完了です。

公式のREADMEに従ってホスティングします。

#### 補足: prerenderに関して

Rendertoronと同じようなものに、prerenderというものがあります。

https://github.com/prerender/prerender

こちらのライブラリもRendertoronと同様にHeadless Chromiumを使用して事前レンダリングを行うミドルウェアです。
Rendertoronとの違いはスクリプトタグを排除する処理はなく、また、プラグインを書いて任意の処理を挿入できます
そのため、実は今回のアーキテクチャにはPrerenderの方が最適です。

しかし、サーバレスでのホスティングが想定されておらず、Chromiumの立ち上がりよりも前にサーバのポートListenが始まってしまいまいます。  
それに関してはパッチを当てれば対応できますが、Chromiumのプロセスの管理がサーバレスと相性が良くないために、レンダリングが失敗するケースが多発してしまい、あえなくRendertoronを選択しています。

サーバレスな構成をとらないのであれば、Rendertoronのほうがスムーズに構築ができると思いますので、自身の環境にあったものを選択してください。

## 二重データフェッチの抑制



### Hydrateの抑制

## パフォーマンスの変化

## まとめ
