---
title: "Next.jsのISRを独自に実装する ~レンダリングミドルウェアによるCSRサイトのSG化~"
emoji: "🍋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs","react","rendertron"]
published: false
---

## この記事は何？

この記事は、「Next.jsのISRを独自に実装する」という記事の続編になります。

https://zenn.dev/chimame/articles/7570c71d1e6c38

まだ目を通してない方は合わせてご覧になることをおすすめします。

この記事では、上の記事中で紹介しきれなかった、CSRなページ・SPAなコンテンツをSGなページに変換するということについて紹介していきます。  

:::message
「Next.jsの`getStaticProps`や`getServerSideProps`を使ってサーバサイドレンダリングすればいいじゃん」は、今回は無しでお願いします 🙇‍

この記事では、CSR/SPAで構築されているコンテンツの現行のコードを、大きく変えることなくスタティックなページとして配信することを目指します。

諸事情によりシステムのリプレースは現実的ではないが、CWVを向上させたいというケースに最適です。
:::

## アーキテクチャ

上の記事にでも説明されていた概要図をそのまま引用しています。  
本記事で説明するのは、Cloudflare Workers以外の部分です。
ここではオリジンをNext.jsにしていますが、Create React Appで作ったようなプレーンなSPAサイトでも構いません。

![](https://storage.googleapis.com/zenn-user-upload/5d5b6ce7aa99-20220625.png)

先に結論から述べると、Workerとオリジンとの間にレンダリングミドルウェアを挟むことで、ユーザの代理でレンダリングをおこない、その結果のHTMLをWorkerにキャッシュさせるといったアーキテクチャになります。

と、言葉で説明するのは簡単ですが、このアーキテクチャを構築するにあたって、解消しなければならない課題がいくつかあります。

- GraphQLクライアント等のデータフェッチが二重に起きないようにしないといけない
  - CSRなページのLCP遅延はデータフェッチによるローディングのサスペンド
  - レンダリングはミドルウェアでデータフェッチがすんでいるので、クライアントではスキップしたい
- レンダリングミドルウェアで得たHTMLを返却して終わりではない
  - 最終的なユーザの手元ではインタラクティブに動くページになっていなければならない
  - 単純にHydrateするとHydrate Mismatchが起きてしまう

### レンダリングミドルウェアに関して

今回のアーキテクチャではRendertronを採用しました。  

https://developers.google.com/search/blog/2019/01/dynamic-rendering-with-rendertron?hl=ja

RendertronはGoogleのweb.devやlighthouseを開発しているコミュニティが作成した、**ダイナミックレンダリング**のためのミドルウェアです。

![ダイナミックレンダリング](https://developers.google.com/static/search/docs/advanced/images/how-dynamic-rendering-works.png?hl=ja)

Headless Chromiumを使用して仮想ブラウザ上でCSR・SPAなサイトをレンダリングし、静的なHTMLのみを返却することができます。  
Googleはユーザエージェントによって、静的なHTMLを返すのか、JSを返却してクライアントでレンダリングさせるのかを切り替えることをダイナミックレンダリングと呼んでいます。

数年前までは、クローラーはJSによるレンダリングの結果を解釈することができず、またJamstackなサイトも今ほどは浸透はしていなかったため、 このような方法で、クローラーフレンドリーなサイトを構築する手法が提案されていました。

### Rendertronの修正

Rendertronを導入するに当たり、少しソースの修正が必要になります。  
Rendertronの本来の目的は完全に静的なHTMLを得ることであり、そのため、最終的にscriptタグを排除したり、baseタグを挿入する実装になっています。  

ここでは、最終的にユーザのクライアントでインタラクティブに動かす必要があるため、このような処理は不要です。  
Rendertronのリポジトリをクローンするか、あるいは`patch-package`等でコードを変更しましょう。

https://github.com/GoogleChrome/rendertron/blob/main/src/renderer.ts#L48-L94

上記コードの`stripPage`と`injectBaseHref`が不要ですのでそれを消します。  

また、レンダリングミドルウェアを通過したHTMLであることを示すエレメントを挿入しておきます。このdivは後ほどの対応の中で使用します。

```ts
// https://github.com/GoogleChrome/rendertron/blob/main/src/rendertron.ts
function preRenderedMark() {
  if (window.extractApolloCache) {
    const e = document.createElement('div');
    e.id = 'x-prerender';
    e.setAttribute('data-x-prerender', '');
    document.body.prepend(e);
  }
}

await page.evaluate(preRenderedMark);
```

あとは公式のREADMEに従ってホスティングすれば、レンダリングミドルウェアの準備は完了です。

#### 補足: Prerenderに関して

Rendertronと同じようなものに、Prerenderというものがあります。

https://github.com/prerender/prerender

こちらのライブラリもRendertronと同様にHeadless Chromiumを使用して事前レンダリングを行うミドルウェアです。
Rendertronと違ってスクリプトタグを排除する処理はなく、また、プラグインを書いて任意の処理を挿入できます。
そのため、実は今回のアーキテクチャにはPrerenderを採用する方が最適です。

しかし、サーバレスでのホスティングが想定されておらず、Chromiumの立ち上がりよりも前にサーバのポートListenが始まってしまい、高頻度で5xxが発生してしまいます。  
これに関してはパッチを当てれば対応できますが、Chromiumのプロセスの管理がサーバレスと相性が良くないために、その後もレンダリングが失敗するケースが多発してしまいました。
今回はCloud Runでホスティングしたかったため、あえなくRendertronを選択しました。

サーバレスな構成をとらないのであれば、Rendertronのほうがスムーズに構築ができると思いますので、自身の環境にあったものを選択してください。

---

レンダリングミドルウェアの準備ができたところで、いくつか追加の対応を行っていきます。

### 二重データフェッチの抑制

レンダリングミドルウェアでは、ユーザのクライアント同様にデータフェッチも行われますが、何も手を打たずに、事前レンダリングした結果を返却すると、もう一度同じデータフェッチがクライアントでも発生してしまいます。  
キャッシュをリストアできるようにすることで、Rendertron上で行われたデータフェッチをクライアント側ではスキップできるようにしましょう。

これはApollo Clientの例です。

:::message
Apollo Clientに限らず、Relay Modernやメジャーなクライアントであれば、サーバサイドレンダリング用にキャッシュのリストア方法を用意してくれていますので、それを活用しましょう。
:::

https://www.apollographql.com/docs/react/v2/caching/cache-interaction/#server-side-rendering

```ts
// apollo-client.ts
const cache = new InMemoryCache()
if (typeof window !== 'undefined') {
  // キャッシュをリストアする
  if (window.__APOLLO_STATE__)
    cache.restore(window.__APOLLO_STATE__)
    
  // キャッシュをhtmlに書き込むための関数
  window.extractApolloCache = () => {
    return JSON.stringify(cache.extract()).replace(/</g, '\\u003c')
  }
}
```

Rendertronの処理を変更し、レンダリング完了後に `window.extractApolloCache()` を実行してキャッシュをbodyに書き込みます。
```ts
// https://github.com/GoogleChrome/rendertron/blob/main/src/rendertron.ts
function apolloCacheInsert() {
  if (window.extractApolloCache) {
    const e = document.createElement('script');
    e.innerHTML = `window.__APOLLO_STATE__=${window.extractApolloCache()}`;
    document.body.prepend(e);
  }
}

await page.evaluate(apolloCacheInsert);
```

ユーザクライアント側では、`cache.restore(window.__APOLLO_STATE__)`の実行を通じて、Apollo Clientのデータストアにキャッシュとしてリストアされます。

さらに、キャッシュポリシーをこのようにしておくことで、最初のフェッチ(ランディング時)はキャッシュを優先し、ナビゲートなど2回目以降は最新のデータをフェッチしにいくようにコントロールできます。
```ts
return new ApolloClient({
  ...,
  defaultOptions: {
    watchQuery: {
      fetchPolicy: 'cache-first',
      nextFetchPolicy: 'cache-and-network',
    },
  },
})
```

こうすることで、Rendertronでのデータフェッチの結果を利用して、ユーザクライアントでのデータフェッチよるサスペンドの発生を解消できます。

## Hydrate Mismatchの解決

:::message
このトピックはクライアントサイドのレンダリングにHydrateを採用している場合に必要な対応です。
素のReactでSPAを構築している場合には省略しても問題ありません。
:::

オリジンにNext.jsを採用している場合、クライアントサイドでの(一度目の)レンダリングはHydrateで解決されます。

https://github.com/vercel/next.js/blob/canary/packages/next/client/index.tsx#L541-L574

これによって仮想DOMをフルでマウントするのをスキップして、イベントハンドラの貼り付けのみでページをインタラクティブな状態にできます。

しかし、これはサーバサイドのレンダリング結果と、クライアントサイドでのマウント前のDOMの構造が完全に一致していなければなりません。
もし不一致を起こしていると、パフォーマンスの低下につながったり、DOM構造自体が壊れてしまう可能性があます。React18ではHydrate Mismatchはワーニングからエラーへ引き上げられました。

今回のアーキテクチャではレンダリングミドルウェアがサーバサイドの役目を果たすため、Rendertron上で生成されたHTMLと、ユーザクライアント上でのDOMの不一致がHydrate Mismatchになります。
たとえば、Dynamic Importなどを利用しているケースの影響が一番大きく、通常のサーバサイドレンダリングでは、Dynamic Importなコンポネントは代替コンポネントで解決されますが、Rendertron上ではコンポネントをロードしてlazyが解決されたあとの状態を返すために、そこが確実にミスマッチになってしまいます。

このHydrate Mismatchを解決するために、少々力技ですが、比較の対象物がずれないようにします。
簡単に説明すると、レンダリングミドルウェアで生成したHTMLを、マウント前に`dangerouslySetInnerHTML`で、そのまま自身の仮想DOMとして扱うことで差異が発生しないようにします。
もちろんマウント直後は、再レンダリングが発生してしまいますので、正しいHydrateと同様のパフォーマンスが得られるわけではありませんが、先の方法でデータフェッチはスキップしていますので、単純なCSRと比べれば十分に早くなっています。

```tsx
// DeceiveHydrateAfterPrerender.tsx
export const DeceiveHydrateAfterPrerender: FC<{ children: ReactNode }> = ({
  children,
}) => {
  const preRendered = usePrerender()
  const [mounted, mount] = useReducer(() => true, false)
  useEffect(() => {
    mount()
  }, [])

  // マウント前にレンダリングミドルウェアで事前生成したHTMLがあればそれを見せる
  if (!mounted && typeof document !== 'undefined' &&
          !!document.getElementById('x-prerender'))
    return (
      <div
        id="deceive-hydrate-target"
        dangerouslySetInnerHTML={{
          __html:
            document.getElementById('deceive-hydrate-target')?.innerHTML ?? '',
        }}
      />
    )

  return <div id="deceive-hydrate-target">{children}</div>
}
```

```tsx
function MyApp({ Component, pageProps }: AppProps) {
  return (
    <DeceiveHydrateAfterPrerender>
      <Head />
      <Component {...pageProps} />
    </DeceiveHydrateAfterPrerender>
  )
}
```

## パフォーマンスの変化

このレンダリングミドルウェアを挟む前後のCSRなページのパフォーマンスをlighthouseで計測してみました。

| レンダリングミドルウェア無し                                       | レンダリングミドルウェア有り                                    |
|------------------------------------------------------|---------------------------------------------------|
| ![](/images/no-rendering-middleware-performance.png) | ![](/images/rendering-middleware-performance.png) |


データフェッチによるサスペンドがなくなり、またランディングした瞬間にすでにレンダリングされた結果が存在しているため、LCPが大きく改善してしていることがわかります。  
また、Time to Interactive は向上しているものの、劇的な改善につながっていないのは、完全なHydrateにはなっておらず、再レンダリングが発生しているためです。

## まとめ

CSR/SPAで構築されたページの配信に、レンダリングミドルウェア挟んでSG化する方法を述べました。  
`getStaticProps`を使ったページのパフォーマンスに勝ることはできませんが、単純なCSR・SPAと比較すると大きくCWVを改善することができますし、事前レンダリングされているのでクローラーフレンドリーでもあります。

また、リアルタムの配信にレンダリングミドルウェアを挟むと、ミドルウェア上でレンダリングを行う分、レスポンスは遅延することに注意してください。
この記事のCloudflare Workersの処理と組み合わせて非同期にレンダリングさせることで、レイテンシを発生させることなく、独自にISRを実現できるようになります。

https://zenn.dev/chimame/articles/7570c71d1e6c38

