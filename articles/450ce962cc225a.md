---
title: "[Next.js] アクセスコントロールパターン"
emoji: "🧱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs","typescript","react"]
published: false
---

## はじめに

Next.js で MPA を構築していると、ページ単位でアクアセスコントロールを行いたいということがあります。
ここでのアクセスコントロールは、ページごとにアクセス可能な条件を定義したり、条件にそぐわない場合に別のページにリダイレクトさせるルールおよび処理を意味します。

例えば、一般向けのページと、登録済みユーザ向けのマイページを持つケースを考えてみます。
- 一般向けページは誰でもアクセス可能
- マイページはログイン済みのユーザのみアクセス可能
- ログインのためのサインイン・アップフォームのページも存在するが、ログイン済みであればマイページにリダイレクトされる
    - ただし、パスワードリセットのフォームは誰でもアクセス可能

今回は上記のルールを実装する上での、いくつかのアクセスコントロールパターンを考えます。

## パターン1: 各ページコンポネント内で制御する

まずは各ページでアクセスコントロールを行うケースです。
便宜上 `isLoggedIn()` の実装は省略します。

```tsx
// pages/mypage.tsx
const Mypage: VFX = (props) => {
  const router = useRouter()
  if (!isLoggedIn()) router.replace('/signin') // ログインしていなければサインインページへ転送

  return <>...</>
}

export default Mypage
```

```tsx
// pages/signin.tsx
const Signin: VFX = (props) => {
  const router = useRouter()
  if (isLoggedIn()) router.replace('/mypage') // ログイン済みであればマイページへ転送

  return <>...</>
}

export default Signin
```

このケースは非常にシンプルです。おそらく誰もが一番最初に思いつくパターンです。
ページ数が少ないうちはこれで問題ないのですが、ページ数が増えてくると破綻しやすくなります。
例えば、`/mypage/a` `/mypage/b` `/mypage/c` のように複数ページある場合、libs 等に制御処理を切り出して共通化しますが、そうすると記述忘れが発生しえます。

- **Pros**
   - シンプル
   - 他ページの制御情報を保つ必要がないので、関心分離が行えている
- **Cons**
   - 設定し忘れが起こり得る
   

## パターン2: _app.ts で集中管理する

```tsx
// pages/_app.tsx

const useAccessControll = () => {
  const router = useRouter()
  useEffect(() => {
    if (router.asPath === '/mypage' && !isLoggedIn())
      router.replace('/signin')
    if (router.asPath === '/signin'  && !isLoggedIn())
      router.replace('/mypge')
  }, [router]) 
}

const App: VFX<AppProps> = ({ Component, pageProps }) => {
  return <Component {...pageProps} />
}

export default App
```


## パターン3: getAccessControl


## 番外編: サーバサイドで制御する