---
title: "コンポーネントを配布する技術について考えてみる"
emoji: "🧩"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react","qwik","cloudflareworkers","designsystem"]
published: false
---

## はじめに

この記事は、Cloudflare が提唱する Fragment Piercing (フラグメント・ピアシング) の記事([Cloudflare Workersによるマイクロフロントエンドの段階的な採用](https://blog.cloudflare.com/ja-jp/fragment-piercing-ja-jp/))を読み、そこから筆者が得た着想とそれをPoC(概念検証)しているものをドキュメント化したものである。

この記事中に出てくるシステムなどは、まだ実用に至っていないものが多く含まれれている。

## デザインシステムとコンポーネントの配布

昨今デザインシステムを構築したり公開する企業や組織が増えている。
「デザインシステム」の価値はStorybookのドキュメントには次のように示されている。

> デザインシステムは複数のプロジェクトを横断してチームが複雑で、丈夫で、アクセシビリティの高いユーザーインターフェースを構築するための再利用可能な UI コンポーネントを包括します。デザイナーと開発者双方が UI コンポーネントに貢献するため、デザインシステムは分野間の架け橋としての役目を果たします。それはまた組織の共通コンポーネントにとって「信頼できる情報源」となります。

https://storybook.js.org/tutorials/design-systems-for-developers/react/ja/introduction/#:~:text=%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AF%E8%A4%87%E6%95%B0%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E6%A8%AA%E6%96%AD%E3%81%97%E3%81%A6%E3%83%81%E3%83%BC%E3%83%A0%E3%81%8C%E8%A4%87%E9%9B%91%E3%81%A7%E3%80%81%E4%B8%88%E5%A4%AB%E3%81%A7%E3%80%81%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B7%E3%83%93%E3%83%AA%E3%83%86%E3%82%A3%E3%81%AE%E9%AB%98%E3%81%84%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%86%8D%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%AA%20UI%20%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%82%92%E5%8C%85%E6%8B%AC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%83%87%E3%82%B6%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%A8%E9%96%8B%E7%99%BA%E8%80%85%E5%8F%8C%E6%96%B9%E3%81%8C%20UI%20%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E8%B2%A2%E7%8C%AE%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AF%E5%88%86%E9%87%8E%E9%96%93%E3%81%AE%E6%9E%B6%E3%81%91%E6%A9%8B%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E5%BD%B9%E7%9B%AE%E3%82%92%E6%9E%9C%E3%81%9F%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%9D%E3%82%8C%E3%81%AF%E3%81%BE%E3%81%9F%E7%B5%84%E7%B9%94%E3%81%AE%E5%85%B1%E9%80%9A%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E3%81%A8%E3%81%A3%E3%81%A6%E3%80%8C%E4%BF%A1%E9%A0%BC%E3%81%A7%E3%81%8D%E3%82%8B%E6%83%85%E5%A0%B1%E6%BA%90%E3%80%8D%E3%81%A8%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82

![](https://storybook.js.org/tutorials/design-systems-for-developers/design-system-overview.jpg)
*https://storybook.js.org/tutorials/design-systems-for-developers/react/ja/introduction/*

もちろん実際の目的や理由は組織によって様々であるが、「デザインのルールや原則を可視化し、UIの再利用性を高め、システム利用者間の知識・経験の隔たりを埋めて、一貫したクオリティのデザインをユーザに提供できるようにすることである」と個人的にはとらえている。

---

このデザインシステムを構築する上において様々な課題や障壁があるが、この記事では **コンポーネントの配布** に焦点をあてて考えたい。

![](https://storybook.js.org/tutorials/design-systems-for-developers/design-system-context.jpg)
*https://storybook.js.org/tutorials/design-systems-for-developers/react/ja/introduction/*

### コンポーネントの配布

![](https://storybook.js.org/tutorials/design-systems-for-developers/design-system-import.png)
*https://storybook.js.org/tutorials/design-systems-for-developers/react/ja/distribute/*

例えば、デザインシステムを構築してコンポーネントを複数のサービスのフロントエンドに配布するケースを考えよう。
よく取られる手法は、npmライブラリとしてUIライブラリを配布する手法である。

https://storybook.js.org/tutorials/design-systems-for-developers/react/ja/distribute/

コンポーネントをビルド・バンドルして、バージョニングしてnpmライブラリとしてパブリッシュし、利用するサービス側でそのライブラリをインポートして使用する。

最も一般的な手法であるが、実際に運用を開始するといくつかの課題が発生する。

#### 課題① 反映までの速度とコスト

配布中のコンポーネントに何らかの変更を加える場合、ビルド・バンドルを行い、ルールに従ってバージョンを進めて再度パブリッシュする。  
利用側では変更内容を確認して、ライブラリをアップグレードして反映する。場合によってはテストや利用側のデプロイが発生する。

これらの作業を確実に挟む必要があるため、デザインシステム側で変更を加えても、即座に利用側に反映されるわけではなく、組織によってそのスピード・タイミングはバラバラである。
何らかの理由によって、「変更の反映のタイミングを揃えなければならない」というケースが発生すると非常にハンドリングしづらい。

また、変更自体が実際のユースケースではうまく動かないこと(デグレ)も起こり得るが、それを修正・反映するにも、再度同じステップを踏まなければならないため、かなりの時間とコストがかかる。
一つのバージョンの中に複数の変更が入っていることも多いので、「コンポーネントAのこの変更を利用したいだけなのに、コンポーネントBの変更も同時に対応しなければならない」ということもある。

:::message
もちろん、このステップを踏むことのメリットもあるので、このnpmライブラリとして配布する手法を否定しているわけではない。
:::

#### 課題② 利用側の技術制限とバンドルサイズ

例えばデザインシステムからコンポーネントをReactで記述する場合、基本的には利用側もReactでシステムが構築していることが前提となる。  
組織の中で統率・統一が行われていれば何の問題もない。しかし、サービスによってはレガシーなシステムを利用していて簡単には置き換えられなかったり、リプレースの過渡期など様々な理由によって、デザインシステム側が採用している(したい)技術と、利用側の実情が乖離してしまうケースもある。

ライブラリ自体をバンドルすればその問題は解消できるが、その分バンドルサイズは大きくなってしまうし、今度はモジュールフェデレーションをどうやって実現するのかという課題が伴ってくる。

## Fragment Piercingの紹介

これらの問題を解消するために Cloudflare が提唱する Fragment Piercing (フラグメント・ピアシング) を紹介する。

Fragment Piercing が登場するのは、この「Cloudflare Workersによるマイクロフロントエンドの段階的な採用」という記事である。

https://blog.cloudflare.com/ja-jp/fragment-piercing-ja-jp/

この記事では、レガシーかつモノリシックなWebアプリケーションに対して、段階的にマイクロフロントエンドを採用していくための手法を紹介している。  
:::message
「マイクロフロントエンド」と聞くと、非常に壮大なシステムを思い浮かべるが、あくまでこの記事内の手法(Fragment Piercing)から着想を得るために紹介しているだけなので、一旦マイクロフロントエンドというキーワードに関しては忘れていただきたい。
:::

ここでいう「フラグメント」とは、機能単位で切り出されたUIパーツであり、フィーチャーコンポーネントとほぼ同意義であると捉えてほしい。

---

![](https://blog.cloudflare.com/content/images/2022/11/image2-41.png)
*[レガシーアプリケーションにピアシングされたフラグメントの図](https://blog.cloudflare.com/ja-jp/fragment-piercing-ja-jp/)*

まずこの図の上部のようなページ(Piercing Outletと書かれたページ)に、フラグメントのコンポーネントをピアシング(インポート)することを考える。

実際にCloudflareが作ったデモアプリケーションがあるので、一度触ってみてほしい。

https://productivity-suite.web-experiments.workers.dev/login

(ユーザ名は任意、パスワードは不要)

画面上部の`Legacy app bootstrap delay`で、ベースのページのアプリケーションの応答速度を調整でき、`Piercing Enabled`でフラグメントピアシングを利用するかしないかを選択できる。
![](https://blog.cloudflare.com/content/images/2022/11/image1-56.png)

`Legacy app bootstrap delay`を3sくらいにし、`Piercing Enabled`のチェックボックスを外すと、擬似的にサイト全体がもっさりしている状態が再現できる。  
続いて、`Legacy app bootstrap delay`をそのままにし、`Piercing Enabled`をオンにしてリロードすると、サイトのもっさり具合は変わらないが、フラグメント部分だけは先にレンダリングが行われることがわかる。

このデモから、`Piercing Enabled`がオンの(フラグメントピアシングを利用している)状態では、「ベースのページとフラグメント部分のレンダリングが分離されている」というイメージがなんとなく湧くだろう。

### Fragment Piercingの解説

![](https://blog.cloudflare.com/content/images/2022/11/Frame-653.png)
*[連携するWorkerとレガシーアプリケーションホストの概要](https://blog.cloudflare.com/ja-jp/fragment-piercing-ja-jp/)*

この図が、先程のデモアプリケーションをどのようにホスティングしているかを表している。

右上の`Legacy application host`がベースのページとなっており、各フラグメントも同じようにホスティングされている。
フラグメントはモジュールをベースのアプリケーションで`import from`で利用しているわけではなく、**単体でホスティングしてサーバサイドレンダリングされている**という点がこのFragment Piercingのミソである。

実際に各フラグメントエンドポイントにアクセスが可能なので、気になる人は見てほしい
- [ログインフラグメント](https://productivity-suite.web-experiments.workers.dev/piercing-fragment/login)
- [TODOリストフラグメント](https://productivity-suite.web-experiments.workers.dev/piercing-fragment/todos) (ログインCookieを持っていないとアクセスできない)
- [ニュースフラグメント](https://productivity-suite.web-experiments.workers.dev/piercing-fragment/news)

これらの独立してホスティングされているフラグメントを、中央の`Piercing Gateway`で結合している状態が、先程のデモアプリケーションで`Piercing Enabled`をオンにしている状態である。
(`Piercing Enabled`がオフのときに関しては後述する)

実際にDev ToolsのNetworkを見てみると、`Piercing Enabled`をオフにしている時は、クライアント側でフラグメントのエンドポイントをフェッチしており、`Piercing Enabled`をオンにしている時は、その通信が発生していないことがわかる。

![](/images/piercing-disabled.png)
*`Piercing Enabled`をオフにしている時はクライアントでフラグメントがフェッチされる*

![](/images/piercing-enabled.png)
*`Piercing Enabled`をオンにしている時は`Piercing Gateway`で結合するのでフラグメントのフェッチが発生しない*

ペースのアプリケーションには、フラグメントを差し込む箇所に次のような`piercing-fragment-outlet`というウェブコンポーネントが記述されている。  

```tsx
export function Login() {
  …
  return (
    <div className="login-page" ref={ref}>
      <piercing-fragment-outlet fragment-id="login" />
    </div>
  );
}
```

`Piercing Enabled`をオフにしている状態では、このウェブコンポーネントがクライアント側でフラグメントのエンドポイントをフェッチし、SSRされたフラグメントのDOMを差し込むようになっている。
`iframe`を使用して、別でホスティングしているパーツ(フラグメント)をページ内に埋め込むような手法の、「`iframe`ではなくウェブコンポーネントを利用する版」と捉えるとイメージがしやすいかもしれない。

https://github.com/cloudflare/workers-web-experiments/blob/main/productivity-suite/piercing-library/src/piercing-fragment-outlet.ts#L88-L120

`Piercing Enabled`がオンの時は、同じような処理をエッジランタイム上で行っており、ベースのアプリケーションにフラグメントのDOMが差し込まれた状態で、最初のHTMLが返却されるといった寸法である。
クライアント側からすると、あたかも最初からフラグメントがベースのアプリケーションから提供されていたかのように振る舞う。

https://github.com/cloudflare/workers-web-experiments/blob/main/productivity-suite/piercing-library/src/piercing-gateway.ts

最後に`Piercing Enabled`がオンの時のフロー図を載せておく。

![](https://blog.cloudflare.com/content/images/2022/11/image4-22.png)
*[ログインページ閲覧時のリクエストのフロー](https://blog.cloudflare.com/ja-jp/fragment-piercing-ja-jp/)*

これが、Fragment PiercingとPiercing Gatewayの仕組みである。

:::message
色々端折ってしまったが、実際の記事にはフラグメント間での通信方法やステートの永続化といった手法についても記載されているので、興味があれば是非自身で記事を読んでほしい。
*[連携するWorkerとレガシーアプリケーションホストの概要](https://blog.cloudflare.com/ja-jp/fragment-piercing-ja-jp/)*
:::

## コンポーネントの配布について再考する

Fragment Piercingがどういったものなのか、どのような仕組みで動いているのかを理解したところで、先のコンポーネントの配布における課題に再フォーカスする。

1. 反映までの速度とコスト
    - npmライブラリを経由するために、利用側はライブラリのアップグレードとそれに伴う作業(再デプロイ)が必要なために、配布側の変更をシームレスに反映することが難しい
2. 利用側の技術制限とバンドルサイズ
    - 配布側と利用側とで使用技術のギャップを考慮する必要があり、場合によってはバンドルサイズやモジュールフェデレーションも考慮しなければならない

これらが、前述した課題であった。

### Fragment Piercingで反映の速度とコストを最小にする

Fragment Piercingがどういった仕組みであるかが理解できていれば、`1. 反映までの速度とコスト`に関しては、解決方法もなんとなく察しが付くだろう。  
コンポーネントをnpmライブラリとして配布するのではなく、コンポーネントごとにホスティングしてサーバサイドレンダリングし、`Piercing Gateway`(エッジランタイム)でフラグメントのDOMを結合するという手法が実現できれば、変更を即時反映しコンポーネントを利用する側は反映にかかるコストを払わなくて良いいことになる。

:::message
実際には、利用側での結合テストやE2Eテストなどを挟まなければならない。
:::

### Qwikでラップして、クライアントのフットプリントを最小にする

残る課題は、`2. 利用側の技術制限とバンドルサイズ`についてである。

例として、コンポーネントをReactで実装することを考える。  
Reactはたとえサーバサイドレンダリングしたとしても、クライアントではハイドレーションする必要があるために、クライアント用のバンドルが必要になる。
完全に静的なコンポーネントであれば、ハイドレーションを無効化できるが、フォームやモーダルを持つようなインタラクティブなコンポーネントとなるとハイドレーションは必要になる。  

また、パーシャルハイドレーションといった、「このコンポーネントだけハイドレーションする」といったことは現在のReactではできず、ページ内に一つでもインタラクティブなコンポーネントが含まれていると、クライアント用のスクリプトを何らかの方法で配布する必要がでてくる。

![](https://blog.saeloun.com/images/useId/server_side_rendering.png)
*https://blog.saeloun.com/2021/12/16/hydration/*

そうなると、クライアントスクリプトが小さめのPreactや、ビルド時にコンパイルされるようなSvelteを採用するのが一番手っ取り早い。
が、実際にはReactのエコシステムや世のトレンドを考慮すると、この課題を解決するためにわざわざマイナーなライブラリを採用して、書き換えるというのは非常に効率が悪い。

そこで利用するのがQwikである。実際に先のFragment Piercingの例でも、フラグメントの構築に一部Qwikが採用されている。  
その理由は、Qwikがクライアントコードを効率よくチャンクし、更にクライアントコードをロードするタイミングを、コンポーネントが操作されたタイミング(あるいは画面内に表示されたタイミングなど)で初めてロードするようになっているので、フットプリントを最小にすることができるためである。

(Qwikについて知りたい人は下の記事を参照してほしい)

https://zenn.dev/aiji42/articles/fafa354f79660d

そして、Qwikには`qwikify$`というReactで記述されたコンポーネントをQwik用のコードに変換するラッパーが存在している。
Qwikの基本概念にある、いつクライアントコードをロードさせるのかという制御も可能となり、「このコンポーネントは完全に静的であるためハイドレーションを必要としない」「このコンポーネントはインタラクティブなパーツだがカーソルがホバーするまではハイドレーションしなくていい」という選択的なスクリプトのロードとハイドレーションができる。

https://qwik.builder.io/docs/integrations/react/

```tsx
/** @jsxImportSource react */
import { qwikify$ } from '@builder.io/qwik-react';
import { useState } from 'react';
 
// Create React component standard way
function Counter() {
  // Print to console to show when the component is rendered.
  console.log('React <Counter/> Render');
  const [count, setCount] = useState(0);
  return (
    <button className="react" onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

// Specify eagerness to hydrate component on hover event.
export const QCounter = qwikify$(Counter, { eagerness: 'hover' });
```

コンポーネント自体は書き慣れたReactと、Reactのエコシステムライブラリを使って作成し、Qwikと`qwikify$`を利用してホスティングすれば、コンポーネント利用側の使用技術に左右されず、またフットプリントも最小に抑えることができる。  
ホスティング部分やビルド部分をいい感じにプラグイン化できれば、開発者はReact以外の技術が使用されているということを全く意識しなくて済むだろう。

また、Qwikでホスティングする利点は他にもあり、一例としてstyleをHTML上に自動的に展開するという特徴が上げられる。  
tailwindやcssモジュールで記述したスタイルが`<style>`タグに変換され、直接HTML上に展開された状態でフラグメントのレスポンスを得る事ができる。  

実際に先の Piercing Fragment の[ログインフラグメント](https://productivity-suite.web-experiments.workers.dev/piercing-fragment/login)を開いてみて、Networkからレスポンスを確認するとわかりやすい。

![](/images/piercing-fragment-style.png)
*QwikはスタイルをHTMLに展開した状態で返却する*

これとウェブコンポーネントのShadowDOMを組み合わせると、スタイルが完全にアイソレートされた状態になるため、ベースのページのスタイルの影響を受けずにコンポーネントを配布することが可能になる。

## システムの概要

これまでの話を図にまとめるとこのような感じになる。

![](/images/component-delivery.png)

ベースとなるアプリケーションは何のライブラリやフレームワーク、あるいはCMSで構築されていても良い。  
コンポーネントをインポートしたい箇所には、`<recat-portable src="https://entry.example.com/component-a" />`このようなウェブコンポーネントのエレメントを差し込む。

コンポーネントの配信システムはQwikで構築されており、コンポーネント自体はReactで記述する。それぞれのコンポーネントに対して、`https://entry.example.com/component-a` と言った感じのURLでアクセスとプレビューが可能な状態にしておく。

Piercing Gateway は Cloudflare Workers で実装されており、ベースのアプリケーションのURL対してのプロキシワーカーとして動くようにしておく。  
ベースのアプリケーションのHTMLを解析し、ウェブコンポーネントの`src`に記述されているエンドポイントにアクセスして、コンポーネントのDOMを受け取って、ベースのHTMLに差し込んでクライアントに返却する。

クライアントではハイドレーションが必要な場合に、スクリプトをコンポーネント配信システムにリクエストしてインタラクティブな操作を受けられるようにする。  
(※この制御は`qwikify$`に任せる)

また、Piercing Gatewayの実装は次のような工夫をしておくことで、可能な限り高速に結合ができるようにしておく
 
- 各コンポーネントのDOMをKVにキャッシュしておく
- ページ内のウェブコンポーネントのリストをKVに保持しておき、`untilWait`でレスポンスを返した後にリストを更新する。
    - なので、実際にはHTMLの解析をして各フラグメントに逐一リクエストするのではなく、ベースアプリケーションのURLから、そのページに必要なコンポーネントのリストを取得できるようにしておく
    - リストに存在していない新規のコンポーネントは、クライアント側でフェッチさせる (エッジ側でも`untilWait`でリストが更新されるので2回目以降は過不足なくエッジ側で結合できる)

TODO:ここにキャッシュのイメージの図を書く

## まとめ

ここにまとめと注意を書く

- Fragment Piercingから得た着想
- システム概要に示したものの実験やサンプルシステムの構築はすでにできている
- 実際に運用したわけではないので、運用課題は多く存在している
    - デザインシステムを引き合いに出したが、どちらかと言うとフィーチャー単位のコンポーネントのメーカーとデリバリを担当する箇所になりそう
